<script>
/* ------ App logic ------ */
const FILES = [
  "Breath(38)Heart(126).mp3",
  "Breath(40)Heart(120).mp3",
  "Breath(42)Heart(144).mp3",
  "Breath(46)Heart(130).mp3",
  "Breath(48)Heart(138).mp3",
  "Breath(50)Heart(144).mp3",
  "Breath(52)Heart(146).mp3",
  "Breath(52)Heart(150).mp3",
];

const audioEl = document.getElementById('audio');
const statusBox = document.getElementById('status');
let currentFile = null;
let truth = {hr:null, rr:null};

function parseRates(filename) {
  const m = filename.match(/Breath\((\d+)\)Heart\((\d+)\)\.mp3$/i);
  if (!m) return { rr: null, hr: null };
  return { rr: parseInt(m[1],10), hr: parseInt(m[2],10) };
}

function setStatus(msg) {
  if (!msg) { statusBox.style.display = 'none'; return; }
  statusBox.style.display = 'block'; statusBox.textContent = msg;
}

async function loadAndPlay(file) {
  currentFile = file;
  truth = parseRates(file);
  document.getElementById('hr').value = '';
  document.getElementById('rr').value = '';
  document.getElementById('hr-actual').textContent = '';
  document.getElementById('rr-actual').textContent = '';
  audioEl.loop = true; audioEl.src = file;
  try { await audioEl.play(); setStatus(''); }
  catch { setStatus('Audio ready. Click ▶/⏸ to start.'); }
}

document.getElementById('new-sound').onclick = () => {
  const next = FILES[Math.floor(Math.random()*FILES.length)];
  loadAndPlay(next);
};

document.getElementById('play-pause').onclick = () => {
  if (!audioEl.src) return;
  if (audioEl.paused) audioEl.play(); else audioEl.pause();
};

document.getElementById('check').onclick = () => {
  if (!currentFile) { setStatus('Click “New sound” first.'); return; }
  const hrVal = parseInt(document.getElementById('hr').value,10);
  const rrVal = parseInt(document.getElementById('rr').value,10);

  const hrOK = Number.isFinite(hrVal) && Math.abs(hrVal - truth.hr) <= 10;
  const rrOK = Number.isFinite(rrVal) && Math.abs(rrVal - truth.rr) <= 5;

  const hrExact = Number.isFinite(hrVal) && hrVal === truth.hr;
  const rrExact = Number.isFinite(rrVal) && rrVal === truth.rr;

  document.getElementById('hr-actual').innerHTML =
    `<span>Actual: <strong>${truth.hr}</strong></span>` +
    (hrOK ? '<span class="badge ok">Correct (±10)</span>' :
             '<span class="badge no">Check count</span>');

  document.getElementById('rr-actual').innerHTML =
    `<span>Actual: <strong>${truth.rr}</strong></span>` +
    (rrOK ? '<span class="badge ok">Correct (±5)</span>' :
             '<span class="badge no">Check count</span>');

  if (hrExact) fireConfettiFromElement(document.getElementById('hr'));
  if (rrExact) fireConfettiFromElement(document.getElementById('rr'));
};

document.getElementById('clear').onclick = () => {
  document.getElementById('hr').value = '';
  document.getElementById('rr').value = '';
  document.getElementById('hr-actual').textContent = '';
  document.getElementById('rr-actual').textContent = '';
};

/* ------ Confetti engine: supports multiple concurrent bursts ------ */
const canvas = document.getElementById('confetti');
const ctx = canvas.getContext('2d');
let W = 0, H = 0;
function resizeCanvas() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
resizeCanvas(); addEventListener('resize', resizeCanvas);

const bursts = []; // each burst = array of particles
let animating = false;
let lastT = 0;

function fireConfettiFromElement(el) {
  const rect = el.getBoundingClientRect();
  const originX = rect.left + rect.width/2;
  const originY = rect.top + rect.height; // bottom of input (in viewport coords)

  // convert to canvas coords (canvas is full-window and not scrolled)
  const x = originX;
  const y = originY;

  const colors = ['#ef4444','#f59e0b','#10b981','#3b82f6','#a855f7','#ec4899'];
  const N = 90;
  const duration = 1800; // ms
  const now = performance.now();

  const particles = [];
  for (let i=0; i<N; i++) {
    const angle = Math.PI/2 + (Math.random()-0.5)*0.6; // mostly downward
    const speed = (0.35 + Math.random()*0.45) * (H/2); // px/s
    particles.push({
      x, y,
      vx: Math.cos(angle)*speed,
      vy: Math.sin(angle)*speed,
      size: 4 + Math.random()*4,
      rot: Math.random()*Math.PI*2,
      vr: (Math.random()-0.5)*0.3,
      color: colors[Math.floor(Math.random()*colors.length)],
      born: now, life: duration
    });
  }
  bursts.push(particles);
  if (!animating) { animating = true; lastT = 0; requestAnimationFrame(loop); }
}

function loop(t) {
  if (!lastT) lastT = t;
  const dt = (t - lastT) / 1000; // seconds
  lastT = t;

  ctx.clearRect(0,0,W,H);

  const g = 0.0015 * H;
  const now = t;

  // update & draw all bursts
  for (let b = bursts.length - 1; b >= 0; b--) {
    const particles = bursts[b];
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      if (now - p.born > p.life) { particles.splice(i,1); continue; }
      p.vy += g*dt;
      p.x  += p.vx*dt;
      p.y  += p.vy*dt;
      p.rot += p.vr;

      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);
      ctx.fillStyle = p.color;
      ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*0.6);
      ctx.restore();
    }
    if (particles.length === 0) bursts.splice(b,1);
  }

  if (bursts.length > 0) requestAnimationFrame(loop);
  else animating = false;
}
</script>
